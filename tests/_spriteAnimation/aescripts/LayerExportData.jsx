function LayerExportData(layer) {    this.layer = layer;            this.nestedComp;    this.parent;        this._name = layer.name;    this.suffix = 0;    this.type = Util.getLayerType(layer);    if(layer.source) this.sourceType = layer.source.typeName;    else this.sourceType = "No source";}LayerExportData.prototype.uniqueName = function() {    var n = Util.cleanName(this._name);    var ns = this.nestedComp;        if(ns != null) n = ns.uniqueName() + "_" + n;        if(this.suffix > 0) n += this.suffix;    return n;}LayerExportData.prototype.uniqueSourceName = function() {    var n = this.layer.source.mainSource.file.name;    var nm  = n.substring (0, n.length-4);        if(this.isSequence()) {        var ns = nm.split("");        while( !isNaN( parseInt(ns[ns.length-1]) ) ) {            ns.pop();        }        nm = ns.join("");    }    return nm;}LayerExportData.prototype.isVisible = function() {    // if null or not enabled do not export data    var b = (this.nestedComp == null) ? !this.layer.nullLayer : this.nestedComp.isVisible();    return b && this.layer.enabled;}LayerExportData.prototype.isSequence = function() {    return this.isAsset() && !this.layer.source.mainSource.isStill;}LayerExportData.prototype.isComposition = function() {    return this.sourceType == "Composition";}// Does the layer contain an asset that needs to be exportedLayerExportData.prototype.isAsset = function() {    return this.type != "Camera" && !(this.layer.source.mainSource instanceof SolidSource);}LayerExportData.prototype.isCamera = function() {    return this.type == "Camera";}LayerExportData.prototype.hasAlpha = function() {    return this.layer.source.mainSource.hasAlpha;}LayerExportData.prototype.numParents = function() {    return (this.parent == null) ? 0 : 1 + this.parent.numParents();}LayerExportData.prototype.sequenceWildcard = function() {    var n = this.layer.source.mainSource.file.name;    var nm  = n.substring (0, n.length-4);    var ext = n.substring (n.length-4, n.length);        var c = 0;    var ns = nm.split("");    while( !isNaN( parseInt(ns[ns.length-1]) ) ) {        c++;        ns.pop();    }    nm = ns.join("");    return nm + "%" + c + "d" + ext;}LayerExportData.prototype.webmFileName = function() {    return this.uniqueSourceName() + ".webm";}LayerExportData.prototype.jpgFileName = function() {    return this.uniqueSourceName() + ".jpg";}LayerExportData.prototype.pngFileName = function() {    return this.uniqueSourceName() + ".png";}LayerExportData.prototype.toString = function() {    return this.uniqueName() + " (" + this.numParents() + ", " + this.isVisible() + ")";}LayerExportData.prototype.getFrame = function(t) {    var key = {};    key.time = t;        var p = this.getPosition(t);    key.px = p[0];    key.py = p[1];    key.pz = p[2];        var s = this.getScale(t);    key.sx = s[0];    key.sy = s[1];    key.sz = s[2];        return key;}LayerExportData.prototype.toObject = function() {            var keyframes = [];        if(this.hasAnimationData()) {        var t = 0;                for(; t <= ExportSettings.duration; t += ExportSettings.samplingRate) {                   keyframes.push( this.getFrame(t) );        }        if(t < ExportSettings.duration) {            keyframes.push( this.getFrame(ExportSettings.duration) );        }    }        var obj = {};        obj.position = this.getPosition(0);    obj.rotation = Util.adaptRotation( this.layer.orientation.valueAtTime(0, false) );    obj.scale    = this.getScale(0);        var offset = this.getOffset(0);    if(offset) obj.offset = offset;        if(this.isSequence()) {        obj.numFrames = ExportSettings.seqFramesPattern.replace ("%fid%", this.uniqueSourceName())    }     if(this.isAsset()) {        obj.texture  = (this.layer.source.mainSource.isStill) ? this.jpgFileName() : this.webmFileName();        obj.alpha = this.hasAlpha();    }    if(this.isCamera()) {        obj.target = this.getPOI(0);        var zoom = this.layer.zoom.valueAtTime(0, false);        var fov = Math.atan2 (ExportSettings.compHeigth/2, zoom) * 180/Math.PI * 2;        obj.fov = fov;    } else {        obj.width = this.layer.width;        obj.height = this.layer.height;    }    if(keyframes.length > 0) obj.keyframes = keyframes;        return obj;}LayerExportData.prototype.getOffset = function(t) {    var d, ds;         if(this.layer["anchorPoint"]) {        var a = this.layer["anchorPoint"].valueAtTime(t, false);        var c = [ (this.layer.width / 2), (this.layer.height / 2), 0 ];        d = [ a[0] - c[0], a[1] - c[1], a[2] - c[2] ];        ds = d[0] + d[1] + d[2];    }    if(ds && !isNaN(ds) && ds != 0) {        return d;    } else {        return null;    }}LayerExportData.prototype.hasAnimationData = function() {    var selfAnim = this.layer.position.isTimeVarying;        var isParentAnim = (this.parent) ? this.parent.hasAnimationData() : false;    var isNestedAnim = (this.nestedComp) ? this.nestedComp.hasAnimationData() : false;        return isParentAnim || isNestedAnim || selfAnim; // Add other exportable values, skip those we do not export}LayerExportData.prototype.getPOI = function(t) {    return Util.adaptPosition( this.calculatePositionVector("pointOfInterest", t) );}LayerExportData.prototype.getPosition = function(t) {    return Util.adaptPosition( this.calculatePositionVector("position", t) );}LayerExportData.prototype.getScale = function(t) {    return this.calculateScaleVector(t);}//LayerExportData.prototype.calculatePositionVector = function(v, t) {    var m = this.layer[v].valueAtTime(t, false);        if(v == "pointOfInterest") v = "position"; // POI needs to be offseted by the position of it's parented/nested elements    if(this.parent) {        var p = this.parent.calculatePositionVector(v, t);           m[0] += p[0];        m[1] += p[1];        m[2] += p[2];    }    if(this.nestedComp) {        var n = this.nestedComp.calculatePositionVector(v, t);                  n[0] = this.nestedComp.layer.width  /2 - n[0];        n[1] = this.nestedComp.layer.height /2 - n[1];                m[0] -= n[0];        m[1] -= n[1];        m[2] += n[2];    }        return m;}LayerExportData.prototype.calculateRotationVector = function(t) {    var m = this.layer["orientation"].valueAtTime(t, false);    var r = this.layer["orientation"].valueAtTime(t, false);        if(this.parent) {        var p = this.parent.calculatePositionVector(v, t);           m[0] += p[0];        m[1] += p[1];        m[2] += p[2];    }    if(this.nestedComp) {        var n = this.nestedComp.calculatePositionVector(v, t);          m[0] += n[0];        m[1] += n[1];        m[2] += n[2];    }        return m;}LayerExportData.prototype.calculateScaleVector = function(t) {        var m = Util.adaptScale( this.layer["scale"].valueAtTime(t, false) );     if(this.parent) {        var p = this.parent.calculateScaleVector(t);           m[0] *= p[0];        m[1] *= p[1];        m[2] *= p[2];    }    if(this.nestedComp) {        var n = this.nestedComp.calculateScaleVector(t);          m[0] *= n[0];        m[1] *= n[1];        m[2] *= n[2];    }        return m;}